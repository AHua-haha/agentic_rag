RESP:


TOOL CALL:
Create new task [Task 1: Analyze how the base agent manages context in the codebase]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for . success

Directory Structure
# .
- dir .git
- file .gitignore
- dir .venv
- dir agent
- dir codebase
- dir context
- file context.log
- dir database
- file go.mod
- file go.sum
- dir litellm
- file llm_dev
- file main.go
- dir model
- file msg.log
- file multilspy_client.py
- dir utils

Directory Definition Overview:
# .

NO Definition Used by Outer code

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for agent success

Directory Structure
# agent
- file baseAgent.go
- file baseAgent_test.go
- file example.md
- file prompt.go

Directory Definition Overview:
# agent

- agent/baseAgent.go
 26| func NewModel(baseurl string, apikey string) *Model {
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for context success

Directory Structure
# context
- file buildContext.go
- file callgraph.go
- file callgraph_test.go
- file contextmgr.go
- file fileContent.go
- file fileContent_test.go
- file outline.go
- file outline_test.go
- file taskManage.go
- file taskManage_test.go

Directory Definition Overview:
# context

- context/buildContext.go
 36| type BuildContextMgr struct {
 37| }

- context/callgraph.go
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {

- context/contextmgr.go
  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }

- context/fileContent.go
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {

- context/outline.go
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {

- context/taskManage.go
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for agent/baseAgent.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file agent/baseAgent.go AgentContext definition success
load file agent/baseAgent.go BaseAgent definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
The BaseAgent manages context through:

1. **AgentContext struct** (agent/baseAgent.go:36) - Main context container with:
   - User prompt and history
   - Pre-task history
   - Context managers (ctxMgr []ctx.ContextMgr)
   - Tool handler map

2. **BaseAgent struct** (agent/baseAgent.go:144) - Has:
   - Model for LLM interaction
   - Root directory path
   - BuildCodeBaseCtxOps for code analysis
   - Message history

3. **Context Integration** - BaseAgent uses multiple context managers from the context package:
   - BuildContextMgr (context/buildContext.go:36)
   - CallGraphMgr (context/callgraph.go:115)  
   - FileContentMgr (context/fileContent.go:92)
   - OutlineCtxMgr (context/outline.go:55)
   - TaskContextMgr (context/taskManage.go:148)

All context managers implement ContextMgr interface (context/contextmgr.go:8) with WriteContext and GetToolDef methods, allowing BaseAgent to write unified context and register tools.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You are now working on:
Task 1: Analyze how the base agent manages context in the codebase (Status: In Progress)
SubTasks:
- Task 1.1: Get overview of the codebase to identify relevant files and directories for base agent and context management (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1: Analyze how different context managers implement the ContextMgr interface]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/contextmgr.go ContextMgr definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- agent/baseAgent.go

 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for context/buildContext.go success
load file context for context/callgraph.go success
load file context for context/fileContent.go success
load file context for context/outline.go success
load file context for context/taskManage.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/buildContext.go WriteContext definition success
load file context/buildContext.go GetToolDef definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/callgraph.go WriteContext definition success
load file context/callgraph.go GetToolDef definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
269| }
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
272| 	findDefHandler := func(argsStr string) (string, error) {
273| 		args := struct {
274| 			File string
275| 			Name string
276| 			Line uint
277| 		}{}
278| 		err := json.Unmarshal([]byte(argsStr), &args)
279| 		if err != nil {
280| 			return "", err
281| 		}
282| 		usedef, err := mgr.findUsedDefs(args.File, args.Name, args.Line)
283| 		if err != nil {
284| 			return err.Error(), nil
285| 		}
286| 		res := mgr.genUseOutput(usedef)
287| 		return res, nil
288| 	}
289| 	findRefHandler := func(argsStr string) (string, error) {
290| 		args := struct {
291| 			File string
292| 			Name string
293| 			Line uint
294| 		}{}
295| 		err := json.Unmarshal([]byte(argsStr), &args)
296| 		if err != nil {
297| 			return "", err
298| 		}
299| 		usedef, err := mgr.findReference(args.File, args.Name, args.Line)
300| 		if err != nil {
301| 			return err.Error(), nil
302| 		}
303| 		res := mgr.genReferenceOutput(usedef)
304| 		return res, nil
305| 	}
306| 	res := []model.ToolDef{
307| 		{FunctionDefinition: findDefUsed, Handler: findDefHandler},
308| 		{FunctionDefinition: findReference, Handler: findRefHandler},
309| 	}
310| 	return res
311| }
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/fileContent.go WriteContext definition success
load file context/fileContent.go GetToolDef definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
269| }
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
272| 	findDefHandler := func(argsStr string) (string, error) {
273| 		args := struct {
274| 			File string
275| 			Name string
276| 			Line uint
277| 		}{}
278| 		err := json.Unmarshal([]byte(argsStr), &args)
279| 		if err != nil {
280| 			return "", err
281| 		}
282| 		usedef, err := mgr.findUsedDefs(args.File, args.Name, args.Line)
283| 		if err != nil {
284| 			return err.Error(), nil
285| 		}
286| 		res := mgr.genUseOutput(usedef)
287| 		return res, nil
288| 	}
289| 	findRefHandler := func(argsStr string) (string, error) {
290| 		args := struct {
291| 			File string
292| 			Name string
293| 			Line uint
294| 		}{}
295| 		err := json.Unmarshal([]byte(argsStr), &args)
296| 		if err != nil {
297| 			return "", err
298| 		}
299| 		usedef, err := mgr.findReference(args.File, args.Name, args.Line)
300| 		if err != nil {
301| 			return err.Error(), nil
302| 		}
303| 		res := mgr.genReferenceOutput(usedef)
304| 		return res, nil
305| 	}
306| 	res := []model.ToolDef{
307| 		{FunctionDefinition: findDefUsed, Handler: findDefHandler},
308| 		{FunctionDefinition: findReference, Handler: findRefHandler},
309| 	}
310| 	return res
311| }
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
125| 	mgr.writeAutoLoadCtx(buf)
126| }
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
129| 	loadFileHandler := func(argsStr string) (string, error) {
130| 		args := struct {
131| 			File []string
132| 		}{}
133| 		err := json.Unmarshal([]byte(argsStr), &args)
134| 		if err != nil {
135| 			return "", err
136| 		}
137| 		res := "IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.\n"
138| 		for _, v := range args.File {
139| 			err := mgr.loadFile(v)
140| 			if err != nil {
141| 				res += fmt.Sprintf("load file context for %s failed, error: %v\n", v, err)
142| 			} else {
143| 				res += fmt.Sprintf("load file context for %s success\n", v)
144| 			}
145| 		}
146| 		return res, nil
147| 	}
148| 	loadDefsHandler := func(argsStr string) (string, error) {
149| 		args := struct {
150| 			File     string
151| 			DefsName []string
152| 		}{}
153| 		err := json.Unmarshal([]byte(argsStr), &args)
154| 		if err != nil {
155| 			return "", err
156| 		}
157| 		res := ""
158| 		for _, name := range args.DefsName {
159| 			err := mgr.loadDefs(args.File, name)
160| 			if err != nil {
161| 				res += fmt.Sprintf("load file %s %s definition failed, error: %v\n", args.File, name, err)
162| 			} else {
163| 				res += fmt.Sprintf("load file %s %s definition success\n", args.File, name)
164| 			}
165| 		}
166| 		return res, nil
167| 	}
168| 	res := []model.ToolDef{
169| 		{FunctionDefinition: loadFileTool, Handler: loadFileHandler},
170| 		{FunctionDefinition: loadFileDefsTool, Handler: loadDefsHandler},
171| 	}
172| 	return res
173| }
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/outline.go WriteContext definition success
load file context/outline.go GetToolDef definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
269| }
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
272| 	findDefHandler := func(argsStr string) (string, error) {
273| 		args := struct {
274| 			File string
275| 			Name string
276| 			Line uint
277| 		}{}
278| 		err := json.Unmarshal([]byte(argsStr), &args)
279| 		if err != nil {
280| 			return "", err
281| 		}
282| 		usedef, err := mgr.findUsedDefs(args.File, args.Name, args.Line)
283| 		if err != nil {
284| 			return err.Error(), nil
285| 		}
286| 		res := mgr.genUseOutput(usedef)
287| 		return res, nil
288| 	}
289| 	findRefHandler := func(argsStr string) (string, error) {
290| 		args := struct {
291| 			File string
292| 			Name string
293| 			Line uint
294| 		}{}
295| 		err := json.Unmarshal([]byte(argsStr), &args)
296| 		if err != nil {
297| 			return "", err
298| 		}
299| 		usedef, err := mgr.findReference(args.File, args.Name, args.Line)
300| 		if err != nil {
301| 			return err.Error(), nil
302| 		}
303| 		res := mgr.genReferenceOutput(usedef)
304| 		return res, nil
305| 	}
306| 	res := []model.ToolDef{
307| 		{FunctionDefinition: findDefUsed, Handler: findDefHandler},
308| 		{FunctionDefinition: findReference, Handler: findRefHandler},
309| 	}
310| 	return res
311| }
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
125| 	mgr.writeAutoLoadCtx(buf)
126| }
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
129| 	loadFileHandler := func(argsStr string) (string, error) {
130| 		args := struct {
131| 			File []string
132| 		}{}
133| 		err := json.Unmarshal([]byte(argsStr), &args)
134| 		if err != nil {
135| 			return "", err
136| 		}
137| 		res := "IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.\n"
138| 		for _, v := range args.File {
139| 			err := mgr.loadFile(v)
140| 			if err != nil {
141| 				res += fmt.Sprintf("load file context for %s failed, error: %v\n", v, err)
142| 			} else {
143| 				res += fmt.Sprintf("load file context for %s success\n", v)
144| 			}
145| 		}
146| 		return res, nil
147| 	}
148| 	loadDefsHandler := func(argsStr string) (string, error) {
149| 		args := struct {
150| 			File     string
151| 			DefsName []string
152| 		}{}
153| 		err := json.Unmarshal([]byte(argsStr), &args)
154| 		if err != nil {
155| 			return "", err
156| 		}
157| 		res := ""
158| 		for _, name := range args.DefsName {
159| 			err := mgr.loadDefs(args.File, name)
160| 			if err != nil {
161| 				res += fmt.Sprintf("load file %s %s definition failed, error: %v\n", args.File, name, err)
162| 			} else {
163| 				res += fmt.Sprintf("load file %s %s definition success\n", args.File, name)
164| 			}
165| 		}
166| 		return res, nil
167| 	}
168| 	res := []model.ToolDef{
169| 		{FunctionDefinition: loadFileTool, Handler: loadFileHandler},
170| 		{FunctionDefinition: loadFileDefsTool, Handler: loadDefsHandler},
171| 	}
172| 	return res
173| }
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
101| }
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
135| 	dirOverviewHandler := func(argsStr string) (string, error) {
136| 		args := struct {
137| 			Path string
138| 		}{}
139| 		err := json.Unmarshal([]byte(argsStr), &args)
140| 		if err != nil {
141| 			return "", err
142| 		}
143| 		var buf bytes.Buffer
144| 		mgr.writeOverview(&buf, args.Path)
145| 		return buf.String(), nil
146| 	}
147| 	res := []model.ToolDef{
148| 		{FunctionDefinition: dirOverview, Handler: dirOverviewHandler},
149| 	}
150| 	return res
151| }
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file context/taskManage.go WriteContext definition success
load file context/taskManage.go GetToolDef definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
239| 	buf.WriteString(taskPrompt)
240| 	mgr.writeTaskList(buf)
241| 	buf.WriteString("### END OF TASK MANAGEMENT ###\n")
242| }
243| 
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
246| 		args := struct {
247| 			Content string
248| 			Type    string
249| 		}{}
250| 		err := json.Unmarshal([]byte(argsStr), &args)
251| 		if err != nil {
252| 			return "", err
253| 		}
254| 		var subtask bool
255| 		if args.Type == "subtask" {
256| 			subtask = true
257| 		} else if args.Type == "main task" {
258| 			subtask = false
259| 		}
260| 		return mgr.createTask(args.Content, subtask), nil
261| 	}
262| 	finishTaskHandler := func(argsStr string) (string, error) {
263| 		args := struct {
264| 			Summary string
265| 			Type    string
266| 		}{}
267| 		err := json.Unmarshal([]byte(argsStr), &args)
268| 		if err != nil {
269| 			return "", err
270| 		}
271| 		var subtask bool
272| 		if args.Type == "subtask" {
273| 			subtask = true
274| 		} else if args.Type == "main task" {
275| 			subtask = false
276| 		}
277| 		return mgr.finishTask(args.Summary, subtask), nil
278| 	}
279| 	res := []model.ToolDef{
280| 		{FunctionDefinition: createTask, Handler: createTaskHandler},
281| 		{FunctionDefinition: finishTask, Handler: finishTaskHandler},
282| 	}
283| 	return res
284| }
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
269| }
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
272| 	findDefHandler := func(argsStr string) (string, error) {
273| 		args := struct {
274| 			File string
275| 			Name string
276| 			Line uint
277| 		}{}
278| 		err := json.Unmarshal([]byte(argsStr), &args)
279| 		if err != nil {
280| 			return "", err
281| 		}
282| 		usedef, err := mgr.findUsedDefs(args.File, args.Name, args.Line)
283| 		if err != nil {
284| 			return err.Error(), nil
285| 		}
286| 		res := mgr.genUseOutput(usedef)
287| 		return res, nil
288| 	}
289| 	findRefHandler := func(argsStr string) (string, error) {
290| 		args := struct {
291| 			File string
292| 			Name string
293| 			Line uint
294| 		}{}
295| 		err := json.Unmarshal([]byte(argsStr), &args)
296| 		if err != nil {
297| 			return "", err
298| 		}
299| 		usedef, err := mgr.findReference(args.File, args.Name, args.Line)
300| 		if err != nil {
301| 			return err.Error(), nil
302| 		}
303| 		res := mgr.genReferenceOutput(usedef)
304| 		return res, nil
305| 	}
306| 	res := []model.ToolDef{
307| 		{FunctionDefinition: findDefUsed, Handler: findDefHandler},
308| 		{FunctionDefinition: findReference, Handler: findRefHandler},
309| 	}
310| 	return res
311| }
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
125| 	mgr.writeAutoLoadCtx(buf)
126| }
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
129| 	loadFileHandler := func(argsStr string) (string, error) {
130| 		args := struct {
131| 			File []string
132| 		}{}
133| 		err := json.Unmarshal([]byte(argsStr), &args)
134| 		if err != nil {
135| 			return "", err
136| 		}
137| 		res := "IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.\n"
138| 		for _, v := range args.File {
139| 			err := mgr.loadFile(v)
140| 			if err != nil {
141| 				res += fmt.Sprintf("load file context for %s failed, error: %v\n", v, err)
142| 			} else {
143| 				res += fmt.Sprintf("load file context for %s success\n", v)
144| 			}
145| 		}
146| 		return res, nil
147| 	}
148| 	loadDefsHandler := func(argsStr string) (string, error) {
149| 		args := struct {
150| 			File     string
151| 			DefsName []string
152| 		}{}
153| 		err := json.Unmarshal([]byte(argsStr), &args)
154| 		if err != nil {
155| 			return "", err
156| 		}
157| 		res := ""
158| 		for _, name := range args.DefsName {
159| 			err := mgr.loadDefs(args.File, name)
160| 			if err != nil {
161| 				res += fmt.Sprintf("load file %s %s definition failed, error: %v\n", args.File, name, err)
162| 			} else {
163| 				res += fmt.Sprintf("load file %s %s definition success\n", args.File, name)
164| 			}
165| 		}
166| 		return res, nil
167| 	}
168| 	res := []model.ToolDef{
169| 		{FunctionDefinition: loadFileTool, Handler: loadFileHandler},
170| 		{FunctionDefinition: loadFileDefsTool, Handler: loadDefsHandler},
171| 	}
172| 	return res
173| }
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
101| }
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
135| 	dirOverviewHandler := func(argsStr string) (string, error) {
136| 		args := struct {
137| 			Path string
138| 		}{}
139| 		err := json.Unmarshal([]byte(argsStr), &args)
140| 		if err != nil {
141| 			return "", err
142| 		}
143| 		var buf bytes.Buffer
144| 		mgr.writeOverview(&buf, args.Path)
145| 		return buf.String(), nil
146| 	}
147| 	res := []model.ToolDef{
148| 		{FunctionDefinition: dirOverview, Handler: dirOverviewHandler},
149| 	}
150| 	return res
151| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Different context managers implement the ContextMgr interface as follows:

**1. BuildContextMgr** (context/buildContext.go):
- WriteContext: Empty implementation (line 39-40)
- GetToolDef: Returns apply_diff tool for file modification (line 42-58)

**2. CallGraphContextMgr** (context/callgraph.go):  
- WriteContext: Empty implementation (line 268-269)
- GetToolDef: Returns find_used_definition and find_reference tools for code analysis (line 271-310

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# context/contextmgr.go

  8| type ContextMgr interface {
  9| 	WriteContext(buf *bytes.Buffer)
 10| 	GetToolDef() []model.ToolDef
 11| }
# context/buildContext.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var appleDiff = openai.FunctionDefinition{
 14| 	Name:   "apply_diff",
 15| 	Strict: true,
 16| 	Description: `
 17| Apply changes to a file using unified diff format.
 18| 	`,
 19| 	Parameters: jsonschema.Definition{
 20| 		Type:                 jsonschema.Object,
 21| 		AdditionalProperties: false,
 22| 		Properties: map[string]jsonschema.Definition{
 23| 			"file": {
 24| 				Type:        jsonschema.String,
 25| 				Description: "Path to the file to modify",
 26| 			},
 27| 			"diff": {
 28| 				Type:        jsonschema.String,
 29| 				Description: "Complete unified diff showing changes. Must include: --- and +++ headers, @@ hunk markers, context lines (space prefix), removed lines (- prefix), added lines (+ prefix). Include 3-5 lines of context before and after changes.",
 30| 			},
 31| 		},
 32| 		Required: []string{"file", "diff"},
 33| 	},
 34| }
...
 36| type BuildContextMgr struct {
 37| }
...
 39| func (mgr *BuildContextMgr) WriteContext(buf *bytes.Buffer) {
 40| }
...
 42| func (mgr *BuildContextMgr) GetToolDef() []model.ToolDef {
 43| 	applyDiffFunc := func(argsStr string) (string, error) {
 44| 		args := struct {
 45| 			File string
 46| 			Diff string
 47| 		}{}
 48| 		err := json.Unmarshal([]byte(argsStr), &args)
 49| 		if err != nil {
 50| 			return "", err
 51| 		}
 52| 		fmt.Printf("Diff content:\n%s\n", args.Diff)
 53| 		return "apply the edit success", nil
 54| 	}
 55| 	res := []model.ToolDef{
 56| 		{FunctionDefinition: appleDiff, Handler: applyDiffFunc},
 57| 	}
 58| 	return res
 59| }
# context/callgraph.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"errors"
  7| 	"fmt"
  8| 	"llm_dev/codebase/impl"
  9| 	"llm_dev/model"
 10| 	"llm_dev/utils"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| 	"go.mongodb.org/mongo-driver/bson"
 17| )
...
 19| var findReference = openai.FunctionDefinition{
 20| 	Name:   "find_reference",
 21| 	Strict: true,
 22| 	Description: `
 23| This tool is used for finding where some definition is used or referenced. You can use this tool to find where some function or type is used.
 24| This tool help you understand the codebase call graph.
 25| 
 26| <example>
 27| Given some code in utils.go
 28| 
 29| - codebase/common/utils.go
 30| 
 31| 277| type ContextHandler struct {
 32| 278|    OutputChan chan map[string]any
 33| 279|    ctxValue   map[string]any
 34| 280|    handler    HandlerFunc
 35| 281| }
 36| ...
 37| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 38| 
 39| function call: find_reference file = codebase/common/utils.go, name = GetAs, line = 309. find definition which calls function GetAs.
 40| function call: find_reference file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition which uses the struct ContextHandler.
 41| </example>
 42| 	`,
 43| 	Parameters: jsonschema.Definition{
 44| 		Type:                 jsonschema.Object,
 45| 		AdditionalProperties: false,
 46| 		Properties: map[string]jsonschema.Definition{
 47| 			"file": {
 48| 				Type:        jsonschema.String,
 49| 				Description: "the file path of the code e.g. src/codebase",
 50| 			},
 51| 			"name": {
 52| 				Type:        jsonschema.String,
 53| 				Description: "the name of the function or type",
 54| 			},
 55| 			"line": {
 56| 				Type:        jsonschema.Number,
 57| 				Description: "the line num where the function name or type name is declared",
 58| 			},
 59| 		},
 60| 		Required: []string{"file", "name", "line"},
 61| 	},
 62| }
...
 64| var findDefUsed = openai.FunctionDefinition{
 65| 	Name:   "find_used_definition",
 66| 	Strict: true,
 67| 	Description: `
 68| This tool is used for finding all the definition used within some function or type struct.
 69| Use this tool when you do not konw what some symbols actually refer to, where the function or type is declared.
 70| IMPORTANT: DO NOT guess the definition based on only the symbol name, it may leads to wrong definition. You should always use this tool to find the accurate definition used.
 71| 
 72| <example>
 73| Given some code in utils.go
 74| 
 75| - codebase/common/utils.go
 76| 
 77| 277| type ContextHandler struct {
 78| 278|    OutputChan chan map[string]any
 79| 279|    ctxValue   map[string]any
 80| 280|    handler    HandlerFunc
 81| 281| }
 82| ...
 83| 309| func GetAs[T any](ctx *ContextHandler, key string) T {
 84| 
 85| function call: find_used_definition file = codebase/common/utils.go, name = GetAs, line = 309. find all the definition used within the function GetAs.
 86| function call: find_used_definition file = codebase/common/utils.go, name = ContextHandler, line = 277. find all the definition used within the struct ContextHandler.
 87| </example>
 88| 	`,
 89| 	Parameters: jsonschema.Definition{
 90| 		Type:                 jsonschema.Object,
 91| 		AdditionalProperties: false,
 92| 		Properties: map[string]jsonschema.Definition{
 93| 			"file": {
 94| 				Type:        jsonschema.String,
 95| 				Description: "the file path of the code e.g. src/codebase",
 96| 			},
 97| 			"name": {
 98| 				Type:        jsonschema.String,
 99| 				Description: "the name of the function or type",
100| 			},
101| 			"line": {
102| 				Type:        jsonschema.Number,
103| 				Description: "the line num where the function name or type name is declared",
104| 			},
105| 		},
106| 		Required: []string{"file", "name", "line"},
107| 	},
108| }
...
110| type CallGraphContextMgr struct {
111| 	rootPath    string
112| 	buildCtxOps *impl.BuildCodeBaseCtxOps
113| }
...
115| func NewCallGraphMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) CallGraphContextMgr {
...
122| func (mgr *CallGraphContextMgr) genReferenceOutput(usedDefs []impl.UsedDef) string {
...
154| func (mgr *CallGraphContextMgr) genUseOutput(usedDefs []impl.UsedDef) string {
...
212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
...
238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
268| func (mgr *CallGraphContextMgr) WriteContext(buf *bytes.Buffer) {
269| }
...
271| func (mgr *CallGraphContextMgr) GetToolDef() []model.ToolDef {
272| 	findDefHandler := func(argsStr string) (string, error) {
273| 		args := struct {
274| 			File string
275| 			Name string
276| 			Line uint
277| 		}{}
278| 		err := json.Unmarshal([]byte(argsStr), &args)
279| 		if err != nil {
280| 			return "", err
281| 		}
282| 		usedef, err := mgr.findUsedDefs(args.File, args.Name, args.Line)
283| 		if err != nil {
284| 			return err.Error(), nil
285| 		}
286| 		res := mgr.genUseOutput(usedef)
287| 		return res, nil
288| 	}
289| 	findRefHandler := func(argsStr string) (string, error) {
290| 		args := struct {
291| 			File string
292| 			Name string
293| 			Line uint
294| 		}{}
295| 		err := json.Unmarshal([]byte(argsStr), &args)
296| 		if err != nil {
297| 			return "", err
298| 		}
299| 		usedef, err := mgr.findReference(args.File, args.Name, args.Line)
300| 		if err != nil {
301| 			return err.Error(), nil
302| 		}
303| 		res := mgr.genReferenceOutput(usedef)
304| 		return res, nil
305| 	}
306| 	res := []model.ToolDef{
307| 		{FunctionDefinition: findDefUsed, Handler: findDefHandler},
308| 		{FunctionDefinition: findReference, Handler: findRefHandler},
309| 	}
310| 	return res
311| }
# context/fileContent.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"path/filepath"
 11| 	"sort"
 12| 
 13| 	"github.com/sashabaranov/go-openai"
 14| 	"github.com/sashabaranov/go-openai/jsonschema"
 15| )
...
 17| var loadFileTool = openai.FunctionDefinition{
 18| 	Name:   "load_file_context",
 19| 	Strict: true,
 20| 	Description: `
 21| Load the context of a given file.
 22| For source code file, it will load all the definition in the source code.
 23| For example 'load_context_file src/foo.go' will load all definition in source code src/foo.go.
 24| Use this tool when you want to examine the content in certain file
 25| 	`,
 26| 	Parameters: jsonschema.Definition{
 27| 		Type:                 jsonschema.Object,
 28| 		AdditionalProperties: false,
 29| 		Properties: map[string]jsonschema.Definition{
 30| 			"file": {
 31| 				Type: jsonschema.Array,
 32| 				Items: &jsonschema.Definition{
 33| 					Type: jsonschema.String,
 34| 				},
 35| 				Description: `
 36| the file path array to load, e.g. ["src/foo.go", "src/test/bar.go"]
 37| 				`,
 38| 			},
 39| 		},
 40| 		Required: []string{"file"},
 41| 	},
 42| }
...
 44| var loadFileDefsTool = openai.FunctionDefinition{
 45| 	Name:   "load_definition_context",
 46| 	Strict: true,
 47| 	Description: `
 48| Load the context of some definition in a given file.
 49| For example, given code block in file src/foo.go
 50| ` + "```" + `
 51| # src/foo.go
 52| var baseUrl string
 53| type File struct {
 54| 	a int
 55| 	b string
 56| }
 57| 
 58| func GetFileContent(file string)
 59| ` + "```" + `
 60| the code block just show the definition in the code file, if you want to get the detailed content of some definiton,
 61| use this tool to load context of definiton, you should specify two parameters:
 62| - the file path, e.g. src/foo.go
 63| - an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]
 64| 	`,
 65| 	Parameters: jsonschema.Definition{
 66| 		Type:                 jsonschema.Object,
 67| 		AdditionalProperties: false,
 68| 		Properties: map[string]jsonschema.Definition{
 69| 			"file": {
 70| 				Type:        jsonschema.String,
 71| 				Description: "the file path to load, e.g. src/foo.go",
 72| 			},
 73| 			"defsName": {
 74| 				Type: jsonschema.Array,
 75| 				Items: &jsonschema.Definition{
 76| 					Type: jsonschema.String,
 77| 				},
 78| 				Description: `an array of the definition names you want to load, struct name, function name, variable name, e.g. ["baseUrl", "File", "GetFileContent"]`,
 79| 			},
 80| 		},
 81| 		Required: []string{"file", "defsName"},
 82| 	},
 83| }
...
 85| type FileContentCtxMgr struct {
 86| 	rootPath           string
 87| 	BuildCodeBaseCtxop *impl.BuildCodeBaseCtxOps
 88| 
 89| 	autoLoadCtx map[string]*CodeFile
 90| }
...
 92| func NewFileCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) FileContentCtxMgr {
...
101| func (mgr *FileContentCtxMgr) writeAutoLoadCtx(buf *bytes.Buffer) {
...
124| func (mgr *FileContentCtxMgr) WriteContext(buf *bytes.Buffer) {
125| 	mgr.writeAutoLoadCtx(buf)
126| }
...
128| func (mgr *FileContentCtxMgr) GetToolDef() []model.ToolDef {
129| 	loadFileHandler := func(argsStr string) (string, error) {
130| 		args := struct {
131| 			File []string
132| 		}{}
133| 		err := json.Unmarshal([]byte(argsStr), &args)
134| 		if err != nil {
135| 			return "", err
136| 		}
137| 		res := "IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.\n"
138| 		for _, v := range args.File {
139| 			err := mgr.loadFile(v)
140| 			if err != nil {
141| 				res += fmt.Sprintf("load file context for %s failed, error: %v\n", v, err)
142| 			} else {
143| 				res += fmt.Sprintf("load file context for %s success\n", v)
144| 			}
145| 		}
146| 		return res, nil
147| 	}
148| 	loadDefsHandler := func(argsStr string) (string, error) {
149| 		args := struct {
150| 			File     string
151| 			DefsName []string
152| 		}{}
153| 		err := json.Unmarshal([]byte(argsStr), &args)
154| 		if err != nil {
155| 			return "", err
156| 		}
157| 		res := ""
158| 		for _, name := range args.DefsName {
159| 			err := mgr.loadDefs(args.File, name)
160| 			if err != nil {
161| 				res += fmt.Sprintf("load file %s %s definition failed, error: %v\n", args.File, name, err)
162| 			} else {
163| 				res += fmt.Sprintf("load file %s %s definition success\n", args.File, name)
164| 			}
165| 		}
166| 		return res, nil
167| 	}
168| 	res := []model.ToolDef{
169| 		{FunctionDefinition: loadFileTool, Handler: loadFileHandler},
170| 		{FunctionDefinition: loadFileDefsTool, Handler: loadDefsHandler},
171| 	}
172| 	return res
173| }
...
175| func (mgr *FileContentCtxMgr) loadFile(relPath string) error {
...
183| func (mgr *FileContentCtxMgr) loadDefs(relPath string, identifier string) error {
...
192| type CodeFile struct {
193| 	path       string
194| 	ext        string
195| 	defs       []impl.Definition
196| 	loadedDefs []impl.Definition
197| 	usedType   []impl.TypeInfo
198| }
...
200| func NewCodeFile(path string) CodeFile {
...
206| func (file *CodeFile) getContent() utils.FileContent {
...
217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {
...
238| func addDefs(defs []impl.Definition, new []impl.Definition) []impl.Definition {
# context/outline.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/codebase/impl"
  8| 	"llm_dev/model"
  9| 	"llm_dev/utils"
 10| 	"os"
 11| 	"path/filepath"
 12| 
 13| 	"github.com/rs/zerolog/log"
 14| 	"github.com/sashabaranov/go-openai"
 15| 	"github.com/sashabaranov/go-openai/jsonschema"
 16| )
...
 18| var dirOverview = openai.FunctionDefinition{
 19| 	Name:   "get_directory_overview",
 20| 	Strict: true,
 21| 	Description: `
 22| This tool is used for load the definition overview for a file or directory.
 23| The definition overview shows the definition which are declared in the directory and used by code out of the directory.
 24| The definition overview shows how certain file or directory is used by other code.
 25| <example>
 26| directory A has the following structure.
 27| # A
 28| - File test.go
 29| - dir test
 30| - dir utils
 31| - dir codebase
 32| 
 33| function call: get_directory_overview path = "A/test.go", load the definition overview for file A/test.go.
 34| function call: get_directory_overview path = "A/codebase", load the definition overview for directory A/codebase
 35| </example>
 36| 	`,
 37| 	Parameters: jsonschema.Definition{
 38| 		Type:                 jsonschema.Object,
 39| 		AdditionalProperties: false,
 40| 		Properties: map[string]jsonschema.Definition{
 41| 			"path": {
 42| 				Type:        jsonschema.String,
 43| 				Description: "the file path to load, e.g. src/codebase",
 44| 			},
 45| 		},
 46| 		Required: []string{"path"},
 47| 	},
 48| }
...
 50| type OutlineContextMgr struct {
 51| 	rootPath   string
 52| 	buildCtxOp *impl.BuildCodeBaseCtxOps
 53| }
...
 55| func NewOutlineCtxMgr(root string, buildOp *impl.BuildCodeBaseCtxOps) OutlineContextMgr {
...
 62| func (mgr *OutlineContextMgr) writeLeafNode(buf *bytes.Buffer, path string, isDir bool) {
...
100| func (mgr *OutlineContextMgr) WriteContext(buf *bytes.Buffer) {
101| }
...
103| func (mgr *OutlineContextMgr) writeOverview(buf *bytes.Buffer, path string) {
...
134| func (mgr *OutlineContextMgr) GetToolDef() []model.ToolDef {
135| 	dirOverviewHandler := func(argsStr string) (string, error) {
136| 		args := struct {
137| 			Path string
138| 		}{}
139| 		err := json.Unmarshal([]byte(argsStr), &args)
140| 		if err != nil {
141| 			return "", err
142| 		}
143| 		var buf bytes.Buffer
144| 		mgr.writeOverview(&buf, args.Path)
145| 		return buf.String(), nil
146| 	}
147| 	res := []model.ToolDef{
148| 		{FunctionDefinition: dirOverview, Handler: dirOverviewHandler},
149| 	}
150| 	return res
151| }
# context/taskManage.go

  1| package context
...
  3| import (
  4| 	"bytes"
  5| 	"encoding/json"
  6| 	"fmt"
  7| 	"llm_dev/model"
  8| 
  9| 	"github.com/sashabaranov/go-openai"
 10| 	"github.com/sashabaranov/go-openai/jsonschema"
 11| )
...
 13| var taskPrompt = `
 14| You are working on a Thought -> Action -> Summary workflow to help user solve task.
 15| Each phase serve different purpose:
 16| 
 17| - Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
 18| - Action: Use different tools to solve the current task.
 19| - Summary: After the task is finished, summary what this task has done.
 20| 
 21| # Task List
 22| You can create a two level task list:
 23| - Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
 24| - Subtask: each subtask should aim at one concrete thing to solve the main task.
 25| 
 26| Task list Example:
 27| <example>
 28| 
 29| Task 1: Identify the relevant context in the codebase. (Status: completed)
 30| Task 1 Summary: the summary of the conclusion and result of the task.
 31| 
 32| Task 2: Add the log info message. (Status: in progress)
 33| SubTasks:
 34| - Task 2.1: add log info message for function A (status: completed)
 35|   Task 2.1 Summary:
 36| - Task 2.2: add log info message for function B (status: in progress)
 37|   Task 2.2 Summary:
 38| 
 39| </example>
 40| 
 41| # Best Practice
 42| 
 43| Here are some best practice for task management.
 44| 
 45| ## Decompose and create task
 46| 
 47| Good Example to Decompose and Create Task:
 48| 
 49| - Create main task from a high level perspective, Main Task has a overall goal, 
 50|   For example: analyze and identify relevant context for log function, 
 51|   implement the log info function, check error for implementaion, 
 52|   run test for the implementation, fix bug for run test.
 53| 
 54| - Create subtask to solve one concrete part of the main task, 
 55|   For example: identify relevant context for the <symbol>, 
 56|   find out how <symbol> is implemented, find out the main workflow for <symbol>, 
 57|   add log info message for function <name>.
 58| 
 59| 
 60| 
 61| ## Action and Tool Usage
 62| 
 63| Good workflow examples to Identify the relevant context:
 64| - from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
 65| - Based on the used definition in directory, search for relevant context from the used definition.
 66| - Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
 67| - Then use 'load_definition_context' tool to load the complete implementation of the definition.
 68| - Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
 69| - Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.
 70| 
 71| ## Summary task result and conclusion
 72| 
 73| Good Example to symmary task:
 74| - Summary the main task based on all the subtask of the main task.
 75| - Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
 76|   For example: Implement a new log function <identifier> in <file>, 
 77|   function <identifier> in <file> is used for ..., 
 78|   the main workflow is implemented in function <identifier> in <file>
 79| 
 80| - Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go
 81| 
 82| `
 83| var createTask = openai.FunctionDefinition{
 84| 	Name:   "create_task",
 85| 	Strict: true,
 86| 	Description: `
 87| Create a new task, you can create a main task or a subtask, you must specify the content of the task.
 88| You CAN NOT create a new task if the previous task is not completed.
 89| You MUST finish that task first.
 90| `,
 91| 	Parameters: jsonschema.Definition{
 92| 		Type:                 jsonschema.Object,
 93| 		AdditionalProperties: false,
 94| 		Properties: map[string]jsonschema.Definition{
 95| 			"content": {
 96| 				Type:        jsonschema.String,
 97| 				Description: "the content of the task, what this task do",
 98| 			},
 99| 			"type": {
100| 				Type:        jsonschema.String,
101| 				Description: "whether the task is a main task or subtask",
102| 				Enum:        []string{"main task", "subtask"},
103| 			},
104| 		},
105| 		Required: []string{"content", "type"},
106| 	},
107| }
108| var finishTask = openai.FunctionDefinition{
109| 	Name:   "finish_task",
110| 	Strict: true,
111| 	Description: `
112| Finish the current task, you must specify the summary of the task.
113| You MUST finish the subtask first and then finish the main task.
114| `,
115| 	Parameters: jsonschema.Definition{
116| 		Type:                 jsonschema.Object,
117| 		AdditionalProperties: false,
118| 		Properties: map[string]jsonschema.Definition{
119| 			"summary": {
120| 				Type:        jsonschema.String,
121| 				Description: "the summary of this task",
122| 			},
123| 			"type": {
124| 				Type:        jsonschema.String,
125| 				Description: "whether the task is a main task or subtask",
126| 				Enum:        []string{"main task", "subtask"},
127| 			},
128| 		},
129| 		Required: []string{"summary", "type"},
130| 	},
131| }
...
133| type TaskStatus string
...
140| type Task struct {
141| 	TaskID   string
142| 	Content  string
143| 	Summary  string
144| 	Status   TaskStatus
145| 	SubTasks []*Task
146| }
...
148| type TaskContextMgr struct {
149| 	TaskList        []*Task
150| 	CurrentMainTask *Task
151| 	CurrentSubTask  *Task
152| }
...
154| func (mgr *TaskContextMgr) finishTask(summary string, subTask bool) string {
...
176| func (mgr *TaskContextMgr) createTask(content string, subTask bool) string {
...
198| func (mgr *TaskContextMgr) writeTaskList(buf *bytes.Buffer) {
...
238| 	buf.WriteString("### TASK MANAGEMENT ###\n")
239| 	buf.WriteString(taskPrompt)
240| 	mgr.writeTaskList(buf)
241| 	buf.WriteString("### END OF TASK MANAGEMENT ###\n")
242| }
243| 
...
245| 	createTaskHandler := func(argsStr string) (string, error) {
246| 		args := struct {
247| 			Content string
248| 			Type    string
249| 		}{}
250| 		err := json.Unmarshal([]byte(argsStr), &args)
251| 		if err != nil {
252| 			return "", err
253| 		}
254| 		var subtask bool
255| 		if args.Type == "subtask" {
256| 			subtask = true
257| 		} else if args.Type == "main task" {
258| 			subtask = false
259| 		}
260| 		return mgr.createTask(args.Content, subtask), nil
261| 	}
262| 	finishTaskHandler := func(argsStr string) (string, error) {
263| 		args := struct {
264| 			Summary string
265| 			Type    string
266| 		}{}
267| 		err := json.Unmarshal([]byte(argsStr), &args)
268| 		if err != nil {
269| 			return "", err
270| 		}
271| 		var subtask bool
272| 		if args.Type == "subtask" {
273| 			subtask = true
274| 		} else if args.Type == "main task" {
275| 			subtask = false
276| 		}
277| 		return mgr.finishTask(args.Summary, subtask), nil
278| 	}
279| 	res := []model.ToolDef{
280| 		{FunctionDefinition: createTask, Handler: createTaskHandler},
281| 		{FunctionDefinition: finishTask, Handler: finishTaskHandler},
282| 	}
283| 	return res
284| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You are now working on:
Task 1: Analyze how different context managers implement the ContextMgr interface (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1: Analyze database integration and data schema in the project]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for . success

Directory Structure
# .
- dir .git
- file .gitignore
- dir .venv
- dir agent
- dir codebase
- dir context
- file context.log
- dir database
- file go.mod
- file go.sum
- dir litellm
- file llm_dev
- file main.go
- dir model
- file msg.log
- file multilspy_client.py
- dir utils

Directory Definition Overview:
# .

NO Definition Used by Outer code

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for database success

Directory Structure
# database
- file db_client.go
- file db_client_test.go
- file db_ops.go

Directory Definition Overview:
# database

- database/db_client.go
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {

- database/db_ops.go
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for database/db_client.go success
load file context for database/db_ops.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- main.go

 14| func main() {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file main.go main definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load definition overview for codebase success

Directory Structure
# codebase
- dir common
- dir impl
- file parse.go

Directory Definition Overview:
# codebase

- codebase/impl/go_impl_db.go
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file codebase/impl/go_impl_db.go TypeInfo definition success
load file codebase/impl/go_impl_db.go Definition definition success
load file codebase/impl/go_impl_db.go UsedDef definition success
load file codebase/impl/go_impl_db.go BuildCodeBaseCtxOps definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
...
 40| func GetDBClient() *mongo.Client {
...
 47| func CloseDB() {
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
# codebase/impl/go_impl_db.go

 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file database/db_client.go InitDB definition success
load file database/db_client.go GetDBClient definition success
load file database/db_client.go CloseDB definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
# codebase/impl/go_impl_db.go

 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
 20| 	// Read MongoDB URI from environment variable
 21| 	uri = os.Getenv("MONGO_URI")
 22| 	if uri == "" {
 23| 		uri = "mongodb://localhost:27017" // Default URI
 24| 	}
 25| 
 26| 	clientOptions := options.Client().ApplyURI(uri)
 27| 	c, err := mongo.Connect(context.TODO(), clientOptions)
 28| 	if err != nil {
 29| 		log.Fatal().Err(err).Str("url", uri).Msg("connect to mongodb fail")
 30| 	}
 31| 
 32| 	err = c.Ping(context.TODO(), nil)
 33| 	if err != nil {
 34| 		log.Fatal().Err(err).Str("url", uri).Msg("ping mongodb fail")
 35| 	}
 36| 	client = c
 37| 	log.Info().Str("uri", uri).Msg("connect to mongodb")
 38| }
...
 40| func GetDBClient() *mongo.Client {
 41| 	if client == nil {
 42| 		log.Fatal().Msg("db client not init")
 43| 	}
 44| 	return client
 45| }
...
 47| func CloseDB() {
 48| 	if err := client.Disconnect(context.TODO()); err != nil {
 49| 		log.Fatal().Err(err).Msg("disconnect mongodb fail")
 50| 	}
 51| 	log.Info().Str("uri", uri).Msg("disconnect to mongodb")
 52| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You are now working on:
Task 1: Analyze database integration and data schema in the project (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Complete task [Task 1: Analyze database integration and data schema in the project]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
# codebase/impl/go_impl_db.go

 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
 20| 	// Read MongoDB URI from environment variable
 21| 	uri = os.Getenv("MONGO_URI")
 22| 	if uri == "" {
 23| 		uri = "mongodb://localhost:27017" // Default URI
 24| 	}
 25| 
 26| 	clientOptions := options.Client().ApplyURI(uri)
 27| 	c, err := mongo.Connect(context.TODO(), clientOptions)
 28| 	if err != nil {
 29| 		log.Fatal().Err(err).Str("url", uri).Msg("connect to mongodb fail")
 30| 	}
 31| 
 32| 	err = c.Ping(context.TODO(), nil)
 33| 	if err != nil {
 34| 		log.Fatal().Err(err).Str("url", uri).Msg("ping mongodb fail")
 35| 	}
 36| 	client = c
 37| 	log.Info().Str("uri", uri).Msg("connect to mongodb")
 38| }
...
 40| func GetDBClient() *mongo.Client {
 41| 	if client == nil {
 42| 		log.Fatal().Msg("db client not init")
 43| 	}
 44| 	return client
 45| }
...
 47| func CloseDB() {
 48| 	if err := client.Disconnect(context.TODO()); err != nil {
 49| 		log.Fatal().Err(err).Msg("disconnect mongodb fail")
 50| 	}
 51| 	log.Info().Str("uri", uri).Msg("disconnect to mongodb")
 52| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: Completed)
Task 1 Summary: Analyzed the project's database integration and identified three main MongoDB collections with their schemas: TypeInfo for type definitions, Definition for code definitions with location/content ranges, and UsedDef for dependency relationships. The database connection is managed through database/db_client.go with initialization, client retrieval, and cleanup functions.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
The project integrates with MongoDB through three main schemas:

**1. TypeInfo Collection** (codebase/impl/go_impl_db.go:72-79):
```go
type TypeInfo struct {
    ID           primitive.ObjectID // MongoDB _id
    Identifier   string            // Type name
    Keyword      []string          // Language keywords
    DeclareFile  string           // File where declared
    UseFile      string           // File where used
    IsDependency bool             // External dependency flag
}
```

**2. Definition Collection** (codebase/impl/go_impl_db.go:102-111):
```go
type Definition struct {
    ID         primitive.ObjectID // MongoDB _id
    Identifier string            // Function/variable name
    Point      common.Point      // Location in file
    Keyword    []string          // Language keywords
    Summary    utils.Range       // Summary range
    Content    utils.Range       // Full content range
    MinPrefix  string           // Minimum prefix
    RelFile    string           // Relative file path
}
```

**3. UsedDef Collection** (codebase/impl/go_impl_db.go:186-196):
```go
type UsedDef struct {
    ID            primitive.ObjectID // MongoDB _id
    Identifier    string            // Usage identifier
    Keyword       []string          // Keywords
    File          string           // File with usage
    DefIdentifier string           // Referenced definition
    DefKeyword    []string         // Definition keywords
    DefFile       string          // Definition file
    PkgPath       string          // Package path
    Isdependency  bool            // Dependency flag
}
```

**Database Management** (database/db_client.go):
- `InitDB()`: Connects to MongoDB (default: localhost:27017)
- `GetDBClient()`: Returns client instance
- `CloseDB()`: Disconnects from MongoDB

**Operations** (BuildCodeBaseCtxOps): Provides methods to find/generate definitions and dependencies in the "llm_dev" database.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
# database/db_client.go

  1| package database
...
  3| import (
  4| 	"context"
  5| 	"os"
  6| 
  7| 	_ "llm_dev/utils"
  8| 
  9| 	"github.com/rs/zerolog/log"
 10| 
 11| 	"go.mongodb.org/mongo-driver/mongo"
 12| 	"go.mongodb.org/mongo-driver/mongo/options"
 13| )
...
 15| var client *mongo.Client
 16| var uri string
...
 19| func InitDB() {
 20| 	// Read MongoDB URI from environment variable
 21| 	uri = os.Getenv("MONGO_URI")
 22| 	if uri == "" {
 23| 		uri = "mongodb://localhost:27017" // Default URI
 24| 	}
 25| 
 26| 	clientOptions := options.Client().ApplyURI(uri)
 27| 	c, err := mongo.Connect(context.TODO(), clientOptions)
 28| 	if err != nil {
 29| 		log.Fatal().Err(err).Str("url", uri).Msg("connect to mongodb fail")
 30| 	}
 31| 
 32| 	err = c.Ping(context.TODO(), nil)
 33| 	if err != nil {
 34| 		log.Fatal().Err(err).Str("url", uri).Msg("ping mongodb fail")
 35| 	}
 36| 	client = c
 37| 	log.Info().Str("uri", uri).Msg("connect to mongodb")
 38| }
...
 40| func GetDBClient() *mongo.Client {
 41| 	if client == nil {
 42| 		log.Fatal().Msg("db client not init")
 43| 	}
 44| 	return client
 45| }
...
 47| func CloseDB() {
 48| 	if err := client.Disconnect(context.TODO()); err != nil {
 49| 		log.Fatal().Err(err).Msg("disconnect mongodb fail")
 50| 	}
 51| 	log.Info().Str("uri", uri).Msg("disconnect to mongodb")
 52| }
# database/db_ops.go

  1| package database
...
  3| import "go.mongodb.org/mongo-driver/bson"
...
  5| type DataBase struct {
  6| }
...
 18| type MongoDBFilterBuilder struct {
 19| 	filter bson.M
 20| }
...
 22| func NewFilter() MongoDBFilterBuilder {
...
 28| func NewFilterKV(key string, value any) MongoDBFilterBuilder {
...
 34| func (builder *MongoDBFilterBuilder) Build() bson.M {
...
 37| func (builder *MongoDBFilterBuilder) AddKV(key string, value any) *MongoDBFilterBuilder {
...
 41| func (builder *MongoDBFilterBuilder) AddFilter(key string, f MongoDBFilterBuilder) *MongoDBFilterBuilder {
# main.go

  1| package main
...
 14| func main() {
 15| 
 16| 	database.InitDB()
 17| 	defer database.CloseDB()
 18| 	op := impl.BuildCodeBaseCtxOps{
 19| 		RootPath: "/root/workspace/llm_dev",
 20| 		Db:       database.GetDBClient().Database("llm_dev"),
 21| 	}
 22| 	op.RootPath = ""
 23| 	// op.GenAllUsedDefs()
 24| 	// op.SetMinPreFix()
 25| 	model := agent.NewModel("http://192.168.65.2:4000", "sk-1234")
 26| 	agent := agent.NewBaseAgent("/root/workspace/llm_dev", *model)
 27| 	for {
 28| 		reader := bufio.NewScanner(os.Stdin)
 29| 		fmt.Print("User Prompt> ")
 30| 		reader.Scan() // This will read a line of input from the user
 31| 		userprompt := reader.Text()
 32| 
 33| 		agent.NewUserTask(userprompt)
 34| 	}
 35| }
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Analyze database integration and data schema in the project (Status: Completed)
Task 1 Summary: Analyzed the project's database integration and identified three main MongoDB collections with their schemas: TypeInfo for type definitions, Definition for code definitions with location/content ranges, and UsedDef for dependency relationships. The database connection is managed through database/db_client.go with initialization, client retrieval, and cleanup functions.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1: Identify where database queries are performed in the codebase]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- agent/baseAgent.go

152| func NewBaseAgent(codebase string, model Model) BaseAgent {
- main.go

 14| func main() {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
load file codebase/impl/go_impl_db.go GetAllDefContextFunc definition failed, error: file codebase/impl/go_impl_db.go GetAllDefContextFunc definition not found
load file codebase/impl/go_impl_db.go GetDefinitionRange definition failed, error: file codebase/impl/go_impl_db.go GetDefinitionRange definition not found
load file codebase/impl/go_impl_db.go FindExactOrSimilarDef definition failed, error: file codebase/impl/go_impl_db.go FindExactOrSimilarDef definition not found
load file codebase/impl/go_impl_db.go GenerateDefOutline definition failed, error: file codebase/impl/go_impl_db.go GenerateDefOutline definition not found
load file codebase/impl/go_impl_db.go GetBuildOpsUsedDef definition failed, error: file codebase/impl/go_impl_db.go GetBuildOpsUsedDef definition not found
load file codebase/impl/go_impl_db.go FindUsedDefinitionByNameKeyword definition failed, error: file codebase/impl/go_impl_db.go FindUsedDefinitionByNameKeyword definition not found

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for codebase/impl/go_impl_db.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Database queries are performed in the `BuildCodeBaseCtxOps` methods in `codebase/impl/go_impl_db.go`:

**Query Methods:**
- `FindDefs()` (line 722): Queries Definition collection with filter
- `FindUsedDefs()` (line 706): Queries UsedDef collection with filter
- `FindOneDef()` (line 649): Finds single Definition by ID filter

**Insert Methods:**
- `insertDefs()` (line 701): Bulk inserts Definition documents
- `insertUsedTypeInfo()` (line 696): Bulk inserts UsedDef documents

**Usage Points:**
- `agent/baseAgent.go:152`: Creates BuildCodeBaseCtxOps instance via GetDBClient
- Various context managers use BuildCodeBaseCtxOps for code analysis queries
- `FindUsedDefOutline()` (line 343): Queries definitions for specific file paths

TOOL CALL:
Complete task [Task 1: Identify where database queries are performed in the codebase]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: Completed)
Task 1 Summary: Identified database query locations in BuildCodeBaseCtxOps methods: FindDefs, FindUsedDefs, FindOneDef for querying, and insertDefs, insertUsedTypeInfo for insertion. Main usage in agent/baseAgent.go and context managers.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed in the codebase (Status: Completed)
Task 1 Summary: Identified database query locations in BuildCodeBaseCtxOps methods: FindDefs, FindUsedDefs, FindOneDef for querying, and insertDefs, insertUsedTypeInfo for insertion. Main usage in agent/baseAgent.go and context managers.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1.1: Find all database query locations in the codebase]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- main.go

 14| func main() {
- agent/baseAgent.go

152| func NewBaseAgent(codebase string, model Model) BaseAgent {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for codebase/impl/go_impl_db.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- codebase/impl/go_impl_db.go

343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
- context/callgraph.go

212| func (mgr *CallGraphContextMgr) findExactDef(file string, identifier string, line uint) (*impl.Definition, error) {
- context/fileContent.go

217| func (file *CodeFile) loadAllDefs(op *impl.BuildCodeBaseCtxOps) error {
...
229| func (file *CodeFile) loadDefs(identifier string, op *impl.BuildCodeBaseCtxOps) error {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
# The following code use the definition

- context/callgraph.go

238| func (mgr *CallGraphContextMgr) findReference(file string, identifier string, line uint) ([]impl.UsedDef, error) {
...
253| func (mgr *CallGraphContextMgr) findUsedDefs(file string, identifier string, line uint) ([]impl.UsedDef, error) {


CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Complete task [Task 1.1: Find all database query locations in the codebase]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: Completed)
  Task 1.1 Summary: Found database query locations: FindDefs() used in context/callgraph.go:212, context/fileContent.go:217,229 and FindUsedDefs() used in context/callgraph.go:238,253. All queries go through BuildCodeBaseCtxOps in codebase/impl/go_impl_db.go

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1.2: Design and implement logging schema for user prompts, tool calls, and tool results in database]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: Completed)
  Task 1.1 Summary: Found database query locations: FindDefs() used in context/callgraph.go:212, context/fileContent.go:217,229 and FindUsedDefs() used in context/callgraph.go:238,253. All queries go through BuildCodeBaseCtxOps in codebase/impl/go_impl_db.go
- Task 1.2: Design and implement logging schema for user prompts, tool calls, and tool results in database (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.2: Design and implement logging schema for user prompts, tool calls, and tool results in database (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Database queries occur in:
- **context/callgraph.go:212** - FindDefs() for exact definition lookup
- **context/fileContent.go:217,229** - FindDefs() for loading definitions  
- **context/callgraph.go:238,253** - FindUsedDefs() for reference/usage queries

All queries use BuildCodeBaseCtxOps methods that interact with MongoDB collections.

For logging user prompts and tool calls, I'll create a new collection schema:

```go
type ConversationLog struct {
    ID          primitive.ObjectID `bson:"_id,omitempty"`
    Timestamp   time.Time         `bson:"timestamp"`
    SessionID   string           `bson:"session_id"`
    UserPrompt  string           `bson:"user_prompt"`
    ToolCalls   []ToolCall       `bson:"tool_calls"`
}

type ToolCall struct {
    ToolName   string    `bson:"tool_name"`
    Parameters bson.M    `bson:"parameters"`
    Result     string    `bson:"result"`
    Timestamp  time.Time `bson:"timestamp"`
}
```

This will track conversation flow with user inputs and agent responses in one document per conversation turn.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# codebase/impl/go_impl_db.go

  1| package impl
...
  3| import (
  4| 	"context"
  5| 	"fmt"
  6| 	"go/ast"
  7| 	"go/token"
  8| 	"go/types"
  9| 	"io/fs"
 10| 	"llm_dev/codebase/common"
 11| 	"llm_dev/database"
 12| 	"llm_dev/utils"
 13| 	"os"
 14| 	"path/filepath"
 15| 	"sort"
 16| 	"strings"
 17| 
 18| 	"github.com/rs/zerolog/log"
 19| 	ignore "github.com/sabhiram/go-gitignore"
 20| 	tree_sitter "github.com/tree-sitter/go-tree-sitter"
 21| 	golang "github.com/tree-sitter/tree-sitter-go/bindings/go"
 22| 	"go.mongodb.org/mongo-driver/bson"
 23| 	"go.mongodb.org/mongo-driver/bson/primitive"
 24| 	"go.mongodb.org/mongo-driver/mongo"
 25| 	"golang.org/x/tools/go/packages"
 26| )
...
 40| var typeTSQuery *common.TSQuery
 41| var nameTSQuery *common.TSQuery
 42| var varTSQuery *common.TSQuery
...
 44| func InitTSQuery() {
...
 60| func CloseTSQuery() {
...
 72| type TypeInfo struct {
 73| 	ID           primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
 74| 	Identifier   string
 75| 	Keyword      []string
 76| 	DeclareFile  string
 77| 	UseFile      string
 78| 	IsDependency bool
 79| }
...
 81| func (info *TypeInfo) genIDFilter() bson.M {
...
 86| func (info *TypeInfo) genFilterForDef() bson.M {
...
 98| func (info *TypeInfo) addKeyword(value string) {
...
102| type Definition struct {
103| 	ID         primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
104| 	Identifier string
105| 	Point      common.Point
106| 	Keyword    []string
107| 	Summary    utils.Range
108| 	Content    utils.Range
109| 	MinPrefix  string
110| 	RelFile    string
111| }
...
113| func NewDef(node *tree_sitter.Node, data []byte) []Definition {
...
186| type UsedDef struct {
187| 	ID            primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
188| 	Identifier    string
189| 	Keyword       []string
190| 	File          string
191| 	DefIdentifier string
192| 	DefKeyword    []string
193| 	DefFile       string
194| 	PkgPath       string
195| 	Isdependency  bool
196| }
...
198| func NewUseDef(loc types.Object, usedDef types.Object) UsedDef {
...
210| func (use *UsedDef) AddKeyword(value string) {
...
213| func (use *UsedDef) AddDefKeyword(value string) {
...
217| func genTypeInfo(obj types.Object) (string, []string) {
...
250| func GenDefFilter(relfile *string, identifier *string, keyword []string) bson.M {
...
265| func (def *Definition) getValue(key string) any {
...
282| func (def *Definition) genUpdate(keys ...string) bson.M {
...
291| func (def *Definition) genIDFilter() bson.M {
...
297| func (def *Definition) AddKeyword(value string) {
...
301| type FileDirInfo struct {
302| 	ID       primitive.ObjectID `bson:"_id,omitempty"` // Maps to MongoDB _id
303| 	RelPath  string
304| 	IsDir    bool
305| 	UsedDefs []Definition
306| }
...
308| func (fd *FileDirInfo) GetSummary() map[string]utils.FileContent {
...
321| func (fd *FileDirInfo) getDefByFile() map[string][]Definition {
...
334| type BuildCodeBaseCtxOps struct {
335| 	RootPath string
336| 	Db       *mongo.Database
337| }
...
339| func (op *BuildCodeBaseCtxOps) ExtractDefs() {
...
343| func (op *BuildCodeBaseCtxOps) FindUsedDefOutline(relpath string) []Definition {
...
358| func (op *BuildCodeBaseCtxOps) GenAllUsedDefs() {
...
365| func (op *BuildCodeBaseCtxOps) GenAllDefs() {
...
390| func (op *BuildCodeBaseCtxOps) SetMinPreFix() {
...
445| func (op *BuildCodeBaseCtxOps) GenFileMap() map[string]*FileDirInfo {
...
486| func (op *BuildCodeBaseCtxOps) extractUsedTypeInfo(ctx *common.ContextHandler, typeObj types.Object) []UsedDef {
...
557| func (op *BuildCodeBaseCtxOps) typeCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
595| func (op *BuildCodeBaseCtxOps) astCtxHandler(ctx *common.ContextHandler, level uint) bool {
...
621| func (op *BuildCodeBaseCtxOps) fileTreeCtxHandler() common.HandlerFunc {
...
649| func (op *BuildCodeBaseCtxOps) FindOneDef(def Definition) (*Definition, error) {
...
689| func ToAnySlice[T any](input []T) []any {
...
696| func (op *BuildCodeBaseCtxOps) insertUsedTypeInfo(array []UsedDef) {
...
701| func (op *BuildCodeBaseCtxOps) insertDefs(array []Definition) {
...
706| func (op *BuildCodeBaseCtxOps) FindUsedDefs(filter bson.M) []UsedDef {
...
722| func (op *BuildCodeBaseCtxOps) FindDefs(filter bson.M) []Definition {
...
739| type FileTreeCtx struct {
740| 	Path string
741| 	D    fs.DirEntry
742| }
...
744| func (op *BuildCodeBaseCtxOps) WalkProjectFileTree() <-chan FileTreeCtx {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.1: Find all database query locations in the codebase (Status: Completed)
  Task 1.1 Summary: Found database query locations: FindDefs() used in context/callgraph.go:212, context/fileContent.go:217,229 and FindUsedDefs() used in context/callgraph.go:238,253. All queries go through BuildCodeBaseCtxOps in codebase/impl/go_impl_db.go
- Task 1.2: Design and implement logging schema for user prompts, tool calls, and tool results in database (Status: In Progress)

You are now working on:
Task 1: Identify where database queries are performed and implement logging for user prompts, tool calls, and tool call results (Status: In Progress)
SubTasks:
- Task 1.2: Design and implement logging schema for user prompts, tool calls, and tool results in database (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Create new task [Task 1: Add log info message for base agent workflow]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
I need to first understand the codebase structure to identify where the base agent workflow is implemented.

TOOL CALL:
load definition overview for . success

Directory Structure
# .
- dir .git
- file .gitignore
- dir .venv
- dir agent
- dir codebase
- dir context
- file context.log
- dir database
- file go.mod
- file go.sum
- dir litellm
- file llm_dev
- file main.go
- dir model
- file msg.log
- file multilspy_client.py
- dir utils

Directory Definition Overview:
# .

NO Definition Used by Outer code

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Let me look at the agent directory to understand the agent workflow:

TOOL CALL:
load definition overview for agent success

Directory Structure
# agent
- file baseAgent.go
- file baseAgent_test.go
- file example.md
- file prompt.go

Directory Definition Overview:
# agent

- agent/baseAgent.go
 26| func NewModel(baseurl string, apikey string) *Model {
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {

IMPORTANT: This only shows the definition declared within one directory or file and used by code out of this directory or file. Definitions not being used is omitted. You can use 'load_file_context' and 'load_definition_context' tools to check the detailed context.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Now let me examine the base agent file to understand the workflow:

TOOL CALL:
IMPORTANT: This only load the definitions in file, the implementations of definition is omitted. You can use 'load_definition_context' tool to load it.
load file context for agent/baseAgent.go success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Let me load the key functions to understand the workflow:

TOOL CALL:
load file agent/baseAgent.go NewUserTask definition success
load file agent/baseAgent.go handleResponse definition success

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Based on the code, I can see the base agent workflow has key points where logging would be useful. Let me create a subtask to analyze the specific workflow points:

TOOL CALL:
Create new task [Task 1.1: Identify key workflow points in base agent that need log info messages]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
From analyzing the code, I can identify several key workflow points in the base agent that would benefit from log info messages:

1. **Task initialization** in `NewUserTask` (line 242) - when a new user task starts
2. **Request generation** (line 254) - when generating chat completion request  
3. **Stream creation** (line 255) - when creating chat completion stream
4. **Response handling start** (line 192) - when starting to handle response
5. **Task completion** (line 262-266) - when task finishes and history is updated

TOOL CALL:
Complete task [Task 1.1: Identify key workflow points in base agent that need log info messages]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: Completed)
  Task 1.1 Summary: Identified 5 key workflow points in base agent that need log info messages: task initialization, request generation, stream creation, response handling start, and task completion

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Now I'll create a subtask to implement the log info messages:

TOOL CALL:
Create new task [Task 1.2: Implement log info messages at identified workflow points in base agent]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: Completed)
  Task 1.1 Summary: Identified 5 key workflow points in base agent that need log info messages: task initialization, request generation, stream creation, response handling start, and task completion
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
I'll add log info messages at the key workflow points. The code already imports `"github.com/rs/zerolog/log"` so I can use the existing logging setup:

TOOL CALL:
apply the edit success
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: Completed)
  Task 1.1 Summary: Identified 5 key workflow points in base agent that need log info messages: task initialization, request generation, stream creation, response handling start, and task completion
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Now I'll add a log message at the start of response handling:

TOOL CALL:
apply the edit success
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: Completed)
  Task 1.1 Summary: Identified 5 key workflow points in base agent that need log info messages: task initialization, request generation, stream creation, response handling start, and task completion
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Complete task [Task 1.2: Implement log info messages at identified workflow points in base agent]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: In Progress)
SubTasks:
- Task 1.1: Identify key workflow points in base agent that need log info messages (Status: Completed)
  Task 1.1 Summary: Identified 5 key workflow points in base agent that need log info messages: task initialization, request generation, stream creation, response handling start, and task completion
- Task 1.2: Implement log info messages at identified workflow points in base agent (Status: Completed)
  Task 1.2 Summary: Added log info messages at 5 key workflow points: task start with user prompt, request generation, stream creation, response handling start, and task completion with history update

You are now working on:
Task 1: Add log info message for base agent workflow (Status: In Progress)

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:


TOOL CALL:
Complete task [Task 1: Add log info message for base agent workflow]
CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: Completed)
Task 1 Summary: Successfully added log info messages to base agent workflow at 5 key points: task initialization with user prompt logging, request generation, stream creation, response handling start, and task completion with history update. All messages use structured logging with zerolog.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
RESP:
Added log info messages to the base agent workflow at key points: task initialization, request generation, stream creation, response handling, and task completion. The messages use structured logging with zerolog for better observability.

CONTEXT:
## CODEBASE LOADED FILE CONTEXT ##


This section shows all the previous loaded context using tools "load_definition_context" and "load_file_context".
If you need some relevant context, use tools "load_definition_context" and "load_file_context" to load.
You should:
- Examine the user's request and available codebase context information
- Determine what context is truly relevant for the task.
- If you need certain context, load the relevant context using the tools provided.
- If NO additional context is needed, Continue with your response conversationally

```
# agent/baseAgent.go

  1| package agent
...
  3| import (
  4| 	"bytes"
  5| 	"context"
  6| 	"encoding/json"
  7| 	"errors"
  8| 	"fmt"
  9| 	"io"
 10| 	"llm_dev/codebase/impl"
 11| 	ctx "llm_dev/context"
 12| 	"llm_dev/database"
 13| 	"llm_dev/model"
 14| 	"os"
 15| 
 16| 	"github.com/rs/zerolog/log"
 17| 	"github.com/sashabaranov/go-openai"
 18| )
...
 20| type Model struct {
 21| 	*openai.Client
 22| 	apikey  string
 23| 	baseUrl string
 24| }
...
 26| func NewModel(baseurl string, apikey string) *Model {
...
 36| type AgentContext struct {
 37| 	userPrompt string
 38| 	history    []openai.ChatCompletionMessage
 39| 	finished   bool
 40| 
 41| 	preTaskHistory []openai.ChatCompletionMessage
 42| 
 43| 	ctxMgr []ctx.ContextMgr
 44| 
 45| 	toolHandlerMap map[string]model.ToolDef
 46| }
...
 48| func NewAgentContext(preHistory []openai.ChatCompletionMessage, userprompt string, ctxMgr ...ctx.ContextMgr) *AgentContext {
...
 61| func (ctx *AgentContext) getResult() []openai.ChatCompletionMessage {
...
 73| func (ctx *AgentContext) genRequest(sysPrompt string) openai.ChatCompletionRequest {
...
103| func (ctx *AgentContext) addMessage(msg openai.ChatCompletionMessage) {
...
106| func (ctx *AgentContext) done() bool {
...
109| func (ctx *AgentContext) writeContext(buf *bytes.Buffer) {
...
115| func (ctx *AgentContext) toolCall(toolCall openai.ToolCall) (openai.ChatCompletionMessage, error) {
...
133| func (ctx *AgentContext) registerTool(tools []model.ToolDef) {
...
144| type BaseAgent struct {
145| 	model   Model
146| 	root    string
147| 	buildOp *impl.BuildCodeBaseCtxOps
148| 
149| 	history []openai.ChatCompletionMessage
150| }
...
152| func NewBaseAgent(codebase string, model Model) BaseAgent {
...
164| type AggregateChunk struct {
165| 	msg       openai.ChatCompletionMessage
166| 	toolCalls map[int]openai.ToolCall
167| }
...
169| func (self *AggregateChunk) addChunk(delta openai.ChatCompletionStreamChoiceDelta) {
...
184| func (self *AggregateChunk) res() openai.ChatCompletionMessage {
...
192| func (agent *BaseAgent) handleResponse(stream *openai.ChatCompletionStream, ctx *AgentContext) {
193| 	var err error
194| 	aggregate := AggregateChunk{
195| 		toolCalls: make(map[int]openai.ToolCall),
196| 	}
197| 	var finishReason openai.FinishReason
198| 	fmt.Printf("RESP:\n")
199| 	for {
200| 		res, e := stream.Recv()
201| 		if e != nil {
202| 			err = e
203| 			break
204| 		}
205| 		finishReason = res.Choices[0].FinishReason
206| 		d := res.Choices[0].Delta
207| 		if d.Content != "" {
208| 			fmt.Print(d.Content)
209| 		}
210| 		aggregate.addChunk(d)
211| 	}
212| 	fmt.Print("END OF RESP\n\n")
213| 	if !errors.Is(err, io.EOF) {
214| 		ctx.finished = true
215| 		return
216| 	}
217| 	file, _ := os.OpenFile("context.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
218| 	resp := aggregate.res()
219| 	file.WriteString(fmt.Sprintf("RESP:\n%s\n\n", resp.Content))
220| 	ctx.addMessage(resp)
221| 	for _, toolCall := range resp.ToolCalls {
222| 		msg, err := ctx.toolCall(toolCall)
223| 		file.WriteString(fmt.Sprintf("TOOL CALL:\n%s\n", msg.Content))
224| 		if err != nil {
225| 			log.Error().Err(err).Any("toolcall", toolCall).Msg("tool call failed")
226| 		} else {
227| 			log.Info().Any("tool call", toolCall).Any("result", msg.Content).Msg("run tool call success")
228| 			ctx.addMessage(msg)
229| 		}
230| 	}
231| 	var buf bytes.Buffer
232| 	ctx.writeContext(&buf)
233| 	file.WriteString("CONTEXT:\n")
234| 	file.Write(buf.Bytes())
235| 	file.Close()
236| 
237| 	if finishReason == openai.FinishReasonStop {
238| 		ctx.finished = true
239| 	}
240| }
...
242| func (agent *BaseAgent) NewUserTask(userprompt string) {
243| 	callGraphMgr := ctx.NewCallGraphMgr(agent.root, agent.buildOp)
244| 	filectxMgr := ctx.NewFileCtxMgr(agent.root, agent.buildOp)
245| 	outlineCtxMgr := ctx.NewOutlineCtxMgr(agent.root, agent.buildOp)
246| 	buildContextMgr := ctx.BuildContextMgr{}
247| 	taskCtxMgr := ctx.TaskContextMgr{}
248| 	ctx := NewAgentContext(agent.history, userprompt, &callGraphMgr, &outlineCtxMgr, &buildContextMgr, &filectxMgr, &taskCtxMgr)
249| 	for {
250| 		// var buf bytes.Buffer
251| 		// // ctx.fileCtxMgr.WriteUsedDefs(&buf)
252| 		// ctx.fileCtxMgr.WriteAutoLoadCtx(&buf)
253| 		// fmt.Print(buf.String())
254| 		req := ctx.genRequest(systemPompt)
255| 		stream, err := agent.model.CreateChatCompletionStream(context.TODO(), req)
256| 		if err != nil {
257| 			log.Error().Err(err).Msg("create chat completion stream failed")
258| 			break
259| 		}
260| 		defer stream.Close()
261| 		agent.handleResponse(stream, ctx)
262| 		if ctx.done() {
263| 			break
264| 		}
265| 	}
266| 	agent.history = append(agent.history, ctx.getResult()...)
267| }
...
269| func DebugMsg(msg *openai.ChatCompletionRequest) {
```
## END OF CODEBASE LOADED FILE CONTEXT ##

### TASK MANAGEMENT ###

You are working on a Thought -> Action -> Summary workflow to help user solve task.
Each phase serve different purpose:

- Thought: examine the user's task and previous finished task, think about what to do next to solve the task, and declare new task.
- Action: Use different tools to solve the current task.
- Summary: After the task is finished, summary what this task has done.

# Task List
You can create a two level task list:
- Main Task: Decompose user's tasks to main tasks by task purpose from a high level perspective.
- Subtask: each subtask should aim at one concrete thing to solve the main task.

Task list Example:
<example>

Task 1: Identify the relevant context in the codebase. (Status: completed)
Task 1 Summary: the summary of the conclusion and result of the task.

Task 2: Add the log info message. (Status: in progress)
SubTasks:
- Task 2.1: add log info message for function A (status: completed)
  Task 2.1 Summary:
- Task 2.2: add log info message for function B (status: in progress)
  Task 2.2 Summary:

</example>

# Best Practice

Here are some best practice for task management.

## Decompose and create task

Good Example to Decompose and Create Task:

- Create main task from a high level perspective, Main Task has a overall goal, 
  For example: analyze and identify relevant context for log function, 
  implement the log info function, check error for implementaion, 
  run test for the implementation, fix bug for run test.

- Create subtask to solve one concrete part of the main task, 
  For example: identify relevant context for the <symbol>, 
  find out how <symbol> is implemented, find out the main workflow for <symbol>, 
  add log info message for function <name>.



## Action and Tool Usage

Good workflow examples to Identify the relevant context:
- from top down, use 'get_directory_overview' tool to get the used definition of a directory. Get a overall understanding of the directory and how the directory is used and what in the directory is used.
- Based on the used definition in directory, search for relevant context from the used definition.
- Use 'load_file_context' tool to load all the definitions in a file, identify which definition is relevant.
- Then use 'load_definition_context' tool to load the complete implementation of the definition.
- Analyze the functionality of definitions, use 'find_reference' tool to examine where the definition is used and how the definition is used, analyze what the definition is used for.
- Analyze definition implementation details, use 'find_used_definition' tool to examine the exact definition used within one function.

## Summary task result and conclusion

Good Example to symmary task:
- Summary the main task based on all the subtask of the main task.
- Summary the result and conclusion of the tasks to short, concise, straightforward statement. 
  For example: Implement a new log function <identifier> in <file>, 
  function <identifier> in <file> is used for ..., 
  the main workflow is implemented in function <identifier> in <file>

- Add reference to the context in the codebase for each statement. Reference format: identifier file, For example: function NewBuildOps in src/agent.go

# Current Task List

Task 1: Add log info message for base agent workflow (Status: Completed)
Task 1 Summary: Successfully added log info messages to base agent workflow at 5 key points: task initialization with user prompt logging, request generation, stream creation, response handling start, and task completion with history update. All messages use structured logging with zerolog.

No in progress task

You can do:
- Keep running the current task, use tools to solve the task.
- If task is finished, finish the task and set summary for task.
- Create a new task to further solve the user's task.

IMPORTANT: If there is NO in progress task, you MUST declare a task first before you execute any actions.
### END OF TASK MANAGEMENT ###
